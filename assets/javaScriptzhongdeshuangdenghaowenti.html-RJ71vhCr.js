import{_ as a,o as s,c as n,e}from"./app-D8pFkU2i.js";const l="/blog/assets/image-20240513163517655-D-SSqqSO.png",p="/blog/assets/image-20240513164415528-s_k8o0sK.png",i="/blog/assets/image-20240513164551847-Sd1_VRvx.png",t="/blog/assets/image-20240513165434532-C-Jh2aYP.png",c={},o=e(`<h1 id="相等和对象的原始转换" tabindex="-1"><a class="header-anchor" href="#相等和对象的原始转换"><span>相等和对象的原始转换</span></a></h1><h2 id="导语" tabindex="-1"><a class="header-anchor" href="#导语"><span>导语</span></a></h2><p>近期在进行<code>JavaScript</code>的基础复习时，发现这么一道面试题：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code><span class="line">/** 请让下面的等式成立*/</span>
<span class="line">if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {</span>
<span class="line">	console.log(&#39;Hello word!&#39;)</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面涉及到<code>==</code>的隐式转换和对象的原始转化问题。</p><h2 id="相等的转化规则" tabindex="-1"><a class="header-anchor" href="#相等的转化规则"><span>相等的转化规则</span></a></h2><p>从上到下按照规则比较，直到能得到确切结果为止：</p><ul><li><p>两端都存在<code>NaN</code>，返回<code>false</code>；</p></li><li><p><code>undefined</code>和<code>null</code>只有与自身比较或者相互比较时，才会返回<code>true</code>；</p></li><li><p>两端类型相同，比较值；</p></li><li><p>两端都是原始类型，转换为数字重新比较；</p></li><li><p>一端为原始类型，一端是对象类型，把对象转化为原始类型重新比较。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token number">NaN</span> <span class="token operator">==</span> <span class="token number">NaN</span>  <span class="token comment">// false</span></span>
<span class="line"><span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">undefined</span> <span class="token comment">// true</span></span>
<span class="line"><span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token comment">// true</span></span>
<span class="line"><span class="token keyword">undefined</span> <span class="token operator">==</span> <span class="token keyword">undefined</span> <span class="token comment">// true</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两端都是原始类型的转化</p><p><img src="`+l+'" alt="image-20240513163517655"></p></li></ul><h2 id="对象转原始类型" tabindex="-1"><a class="header-anchor" href="#对象转原始类型"><span>对象转原始类型</span></a></h2><p>对象转原始类型，按照从上到下的规则进行转化：</p><ul><li><p>如果对象拥有<code>[Symbol.toPrimitive]</code>方式时，调用该方法，若能得到原始值，则使用该原始值，否则抛出异常；</p></li><li><p>调用对象的<code>valueOf</code>方法，如果得到原始值，使用该原始值，否则进入下一步；</p></li><li><p>调用对象的<code>toString</code>方法，如果得到原始值，使用该原始值，否则抛出异常。</p><p><img src="'+p+'" alt="image-20240513164415528"></p></li></ul><p><img src="'+i+`" alt="image-20240513164551847"></p><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h2><p>想要实现最刚开始的等式成立，可以使用下面的方式：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="line"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span></span>
<span class="line">	<span class="token function">valueOf</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">		rerurn <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token operator">++</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+t+'" alt="image-20240513165434532"></p><p>这样每次调用的时都会调用<code>valueOf</code>，这样转化出来的值就成立。</p>',17),d=[o];function r(u,m){return s(),n("div",null,d)}const g=a(c,[["render",r],["__file","javaScriptzhongdeshuangdenghaowenti.html.vue"]]),h=JSON.parse('{"path":"/blogs/javaScriptzhongdeshuangdenghaowenti.html","title":"JavaScript中的双等号问题","lang":"en-US","frontmatter":{"categories":["JavaScript"],"title":"JavaScript中的双等号问题","tags":["双等号","原始对象转化"],"date":"2024-07-17T21:00:00.000Z"},"headers":[{"level":2,"title":"导语","slug":"导语","link":"#导语","children":[]},{"level":2,"title":"相等的转化规则","slug":"相等的转化规则","link":"#相等的转化规则","children":[]},{"level":2,"title":"对象转原始类型","slug":"对象转原始类型","link":"#对象转原始类型","children":[]},{"level":2,"title":"结论","slug":"结论","link":"#结论","children":[]}],"git":{"createdTime":1721275518000,"updatedTime":1721275518000,"contributors":[{"name":"tiantao","email":"tiantao_yb@139.com","commits":1}]},"filePathRelative":"blogs/javaScript中的双等号问题.md"}');export{g as comp,h as data};
