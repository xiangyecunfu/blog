import{_ as n,r as i,o as d,c as u,a as e,d as l,w as a,b as t,e as r}from"./app-D8pFkU2i.js";const h="/blog/assets/react-2-BuQ9zGZn.png",p="/blog/assets/react-1-CMnMPZ9Q.png",_={},f={class:"table-of-contents"},g=r('<h2 id="_1-react和reactdom两个包分别有什么作用" tabindex="-1"><a class="header-anchor" href="#_1-react和reactdom两个包分别有什么作用"><span>1. React和ReactDom两个包分别有什么作用？</span></a></h2><ol><li>react: 这是React库的核心， 它定义了React组件的创建和生命周期方法，以及React元素概念。可以视作React的“引擎”。</li><li>react-dom: 这个库提供了在浏览器环境中使用React的方法， 例如将React组件渲染到DOM中，或者在DOM中触发React组件的更新。可以将其视为React的“驱动程序&quot;</li><li>react-dom/client 是浏览器渲染用的库， 同理node端也有对应的库。</li></ol><h2 id="_2-react为什么有多个包-react是框架吗" tabindex="-1"><a class="header-anchor" href="#_2-react为什么有多个包-react是框架吗"><span>2. React为什么有多个包？ React是框架吗？</span></a></h2><ol><li>为了功能解耦，渲染有渲染的专用包， 引擎就只负责引擎</li><li>React的核心， 其实就是一个渲染的库。</li></ol><h2 id="_2-react组件的渲染过程是怎样的" tabindex="-1"><a class="header-anchor" href="#_2-react组件的渲染过程是怎样的"><span>2. React组件的渲染过程是怎样的？</span></a></h2><ol><li>组件的渲染过程分为两个阶段： <ol><li>挂载阶段（Mounting）：将组件渲染为DOM元素，并将其插入到页面中。</li><li>更新阶段（Updating）：当组件的state或props发生变化时，React会重新渲染组件，并更新DOM元素以反映新的状态或属性。</li></ol></li><li>组件的渲染过程涉及以下步骤： <ol><li>调用组件的render方法，生成虚拟DOM。</li><li>将虚拟DOM转换为真实的DOM元素，并插入到页面中。</li><li>当组件的state或props发生变化时，React会重新调用render方法，生成新的虚拟DOM。</li><li>将新的虚拟DOM与原始的虚拟DOM进行比较，确定需要更新的部分。</li><li>更新需要更新的DOM元素，以反映新的状态或属性。</li></ol></li></ol><h2 id="_3-react中的虚拟dom是什么-它的作用是什么或者优点" tabindex="-1"><a class="header-anchor" href="#_3-react中的虚拟dom是什么-它的作用是什么或者优点"><span>3. React中的虚拟DOM是什么，它的作用是什么或者优点？</span></a></h2><ol><li>虚拟DOM是一种用于描述真实DOM的JavaScript对象。</li><li>虚拟DOM可以用于描述DOM的结构、属性、样式等，并且可以进行高效的比较和更新。</li><li>虚拟DOM可以提高性能和效率，减少对真实DOM的频繁操作。</li><li>跨平台</li></ol><h2 id="_4-严格模式的作用" tabindex="-1"><a class="header-anchor" href="#_4-严格模式的作用"><span>4. 严格模式的作用？</span></a></h2><ol><li>不安全的生命周期方法： 某些生命周期方法在未来的React版本中将被弃用。 严格模式会告警这些不安全方法的使用。</li><li>使用过时或遗留的API：严格模式会警告使用过时或遗留的API。</li><li>意外的副作用： 严格模式可以帮助你发现组件中可能的意外副作用。</li><li>与旧版本React不兼容的代码： 严格模式会警告你的代码中可能与未来版本的React不兼容的部分。</li></ol><h2 id="_5-jsx的作用" tabindex="-1"><a class="header-anchor" href="#_5-jsx的作用"><span>5. <em>JSX</em>的作用？</span></a></h2><ol><li>可以在js中返回dom，经过babel编译成js认识的代码。</li><li>接收两个参数：第一个参数：标签名；第二个参数：子元素以及标签上的一些属性。</li><li>使用_jsx方法进行编译， 这个是来自react底层<code>react/jsx-runtime</code>。</li></ol>',12),m={href:"https://babeljs.io/",target:"_blank",rel:"noopener noreferrer"},v=r('<h2 id="_6-react中的生命周期方法有哪些-它们的作用是什么" tabindex="-1"><a class="header-anchor" href="#_6-react中的生命周期方法有哪些-它们的作用是什么"><span>6. React中的生命周期方法有哪些？它们的作用是什么？</span></a></h2><ol><li>组件的挂载阶段（Mounting）： <ol><li>constructor：用于初始化组件的state和其他属性。</li><li>getDerivedStateFromProps：一个静态方法，接收props和state，可以用于执行一些逻辑返回一个对象更新state，返回值为null时，不更新state，在render之前执行。</li><li>render：初始化渲染页面。</li><li>componentDidMount：在组件挂载到DOM之后执行，可以用于执行一些副作用操作，例如获取DOM元素或发起网络请求。</li></ol></li><li>组件的更新阶段（Updating）： <ol><li>getDerivedStateFromProps：在组件接收到新的props进行调用。</li><li>shouldComponentUpdate：在组件接收到新的props或state之前执行，用于确定是否需要重新渲染组件，作为组件性能优化出现，使用forceUpdate不会触发该钩子。</li><li>render：执行render重新渲染页面。</li><li>getSnapshotBeforeUpdate：在组件更新之前执行，可以用于执行一些副作用操作，例如获取DOM元素或保存一些数据。</li><li>componentDidUpdate：在组件重新渲染并更新到DOM之后执行，可以用于执行一些副作用操作，例如根据新的props或state更新state。</li></ol></li><li>组件的卸载阶段（Unmounting）： <ol><li>componentWillUnmount：在组件卸载之前执行，可以用于执行一些副作用操作，例如清除定时器或取消网络请求。 <img src="'+h+'" alt="React生命周期"></li></ol></li></ol><h2 id="_7-getderivedstatefromprops的作用是什么" tabindex="-1"><a class="header-anchor" href="#_7-getderivedstatefromprops的作用是什么"><span>7. getDerivedStateFromProps的作用是什么？</span></a></h2><p>它的返回值，会对state进行相同属性覆盖修改， 如果没有和state属性相同的就不做修改。</p><ol><li><strong>执行时机</strong>：挂载和更新都会更新，在render之前。</li><li><strong>使用场景：</strong> 进行某些值进行转化（列如后端返回数字状态，前端使用中文显示）。</li><li><strong>注意事项：</strong> 不要在getDerivedStateFromProps中使用setState，否则会死循环。</li></ol><h2 id="_8-getsnapshotbeforeupdate的特点" tabindex="-1"><a class="header-anchor" href="#_8-getsnapshotbeforeupdate的特点"><span>8. getSnapshotBeforeUpdate的特点？</span></a></h2><ol><li><strong>执行时机：</strong> 只会在更新的时候执行，在render之后，浏览器页面更新之前。</li><li><strong>作用：</strong> 返回值可以传递给componentDidUpdate。</li><li><strong>使用场景：</strong> 长列表，需要不断往里面塞入内容。更新之前，记录滚动的位置，传递给<code>componentDidUpdate</code>保持滚轮的位置。 <code>getSnapshotBeforeUpdate</code>更新之前记录滚轮的原始位置，并将原始位置通过<code>return</code>给<code>componentDidUpdate</code>。<code>componentDidUpdate</code>就使用原始的位置更新DOM，保证滚轮不会变化。</li></ol><h2 id="_9-react是mvvm框架嘛" tabindex="-1"><a class="header-anchor" href="#_9-react是mvvm框架嘛"><span>9. React是MVVM框架嘛？</span></a></h2><ol><li>React不是一个典型的MVVM(Model-View-ViewModel)框架，它更倾向于是一个V(View)层库。尽管React可以与其他库(如Redux或Mobx)结合使用以实现丰富的架构，但它本身并没有提供严格的ViewModel层。</li><li>在MVVM模式中，ViewModel作为连接视图(View)和数据(Model)的桥梁的中间层， 负责管理视图的状态和数据，并与数据模型进行交互。而React的设计理念更加集中在组件化的 视图层，通过构建可重用的组件来管理UI状态。</li><li>React强调的是单向数据流的概念， 其中数据从父组件通过props传递给子组件，子组件通过回调函数将状态更改传递回父组件。这种单项数据流的模型有助于构建可预测可维护的组件，但是与典型的双向绑定的MVVM模式不同。</li></ol><h2 id="_10-react如何实现mvvm" tabindex="-1"><a class="header-anchor" href="#_10-react如何实现mvvm"><span>10. React如何实现MVVM？</span></a></h2><p>在React中，可以使用以下方法来实现类似的MVVM的架构：</p><ol><li><strong>使用状态管理库：</strong> React可以与状态管理库(如Redux、Mobx和React Context)结合使用，以实现集中化的状态管理。这些库可以帮助在模型层和视图层之间进行数据传递和状态管理，从而实现MVVM的一部分。</li><li><strong>使用双向数据绑定库：</strong> 第三方库(如mobx-react-lite、reactive-react等)提供了双数数据绑定的能力，它们可以使React组件中的数据与视图保持同步。通过使用这些库，你可以更接近MVVM模式中的双向数据绑定概念。</li><li><strong>自定义视图模型：</strong> 在React中可以定义自己的视图模型或者对象， 将数据逻辑和转换逻辑封装到这些视图模型中。 通过将视图模型与React组件结合使用， 你可以实现数据的映射和处理逻辑。</li></ol><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>React本身是一个非常灵活的库，你可以选择与其他库或者模式结合使用，以满足你的应用程序需求。MVVM只是一种软件设计架构模式，具体实现方式可以根据项目特定要求和团队偏好进行调整。</p></div><h2 id="_11-react的usestate是做什么的-它是同步更新吗" tabindex="-1"><a class="header-anchor" href="#_11-react的usestate是做什么的-它是同步更新吗"><span>11. React的useState是做什么的？ 它是同步更新吗？</span></a></h2><ol><li>用来声明组件中的变量的， 会返回当前的state和一个set函数， set函数用于触发更新state的。</li><li>setState的更新是异步的，React会进行批量操作合并更新。</li></ol><h2 id="_12-react的性能优化hooks有那些-分别有什么作用" tabindex="-1"><a class="header-anchor" href="#_12-react的性能优化hooks有那些-分别有什么作用"><span>12. React的性能优化Hooks有那些？分别有什么作用？</span></a></h2><ol><li><strong>useMemo:</strong><ol><li>useMemo是用来缓存计算结果的。用于缓存计算量过大的函数，避免每次渲染都重新计算。</li><li>适用于当父组件更新时，子组件的重新render计算量比较大，且结果可以复用时，就可以使用useMemo来提升父组件渲染而引起的子组件不必要渲染的性能提升手段。</li></ol></li></ol><div class="custom-container warning"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8v4"></path><path d="M12 16h.01"></path></g></svg><p class="custom-container-title">注意事项</p><p>useMemo在项目中一定是不得已才使用(明显出现了问题)。</p><ol><li>useMemo本身有性能消耗，缓存消耗内存，useMemo自身状态的维护也是有性能开销的。</li><li>useMemo会增加开发成本，代码变得很复杂，不好维护。</li><li>React官方在未来会移除useMemo这个Hook，因为useMemo本身存在一些问题，比如它不能保证缓存结果一定是最新的，因为React的渲染是异步的，所以useMemo的缓存结果可能会被旧的props或state覆盖。</li></ol></div><ol start="2"><li><strong>useCallback:</strong><ol><li>useCallback是用来缓存函数的，避免每次渲染都重新创建函数，从而重新渲染子组件。</li></ol></li></ol><h2 id="_13-react中做组件渲染性能提升怎么做-react渲染规律" tabindex="-1"><a class="header-anchor" href="#_13-react中做组件渲染性能提升怎么做-react渲染规律"><span>13. React中做组件渲染性能提升怎么做？ React渲染规律？</span></a></h2><ol><li>使用<code>memo</code>这个API进行组件包裹，生成一个缓存组件， 如果它的props没有发生变化，那么组件就不会重新render。</li><li><strong>渲染规律:</strong> 只要父组件进行了<code>setState</code>,父组件本身会重新render，所有子组件也会重新render。也就是所谓得全局更新。</li></ol><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">温馨提示</p><ol><li>如果要进行子组件渲染优化，那么useMemo和useCallback必须搭配memo使用，否则没有效果。</li><li>如果子组件没有依赖父组件的props且子组件结构简单，那么子组件就不需要使用memo进行包裹，否则会造成性能浪费。</li></ol></div><h2 id="_14-react的更新是同步还是异步-为什么" tabindex="-1"><a class="header-anchor" href="#_14-react的更新是同步还是异步-为什么"><span>14. React的更新是同步还是异步？ 为什么？</span></a></h2><ol><li>更新是异步的。</li><li>因为React的更新底层的（微任务）异步队列，会将短时间js对组件的修改进行合并，1次完成渲染。</li></ol><h2 id="_15-useeffect和uselayouteffect的区别是什么" tabindex="-1"><a class="header-anchor" href="#_15-useeffect和uselayouteffect的区别是什么"><span>15. useEffect和useLayoutEffect的区别是什么？</span></a></h2><p><img src="'+p+'" alt="React渲染流程图"></p>',26),R=e("li",null,[t("从上图就可以看出， 在js修改dom前会调用"),e("code",null,"useEffect"),t("， 会在单独开辟一个任务队列来执行"),e("code",null,"useEffect"),t(", 这样它就不会阻塞浏览器的渲染；而"),e("code",null,"useLayoutEffect"),t("则是在dom修改结束后，浏览器开始渲染前执行，这样就会导致出现阻塞浏览器渲染。")],-1),M=r('<h2 id="_16-forwardref的作用" tabindex="-1"><a class="header-anchor" href="#_16-forwardref的作用"><span>16. forwardRef的作用？</span></a></h2><ol><li>实际上函数式组件没有ref的。</li><li>我们想获取函数式组件内部的某个dom的实例，那么就可以使用forwardRef转发出去。</li></ol><h2 id="_17-usecontext的作用" tabindex="-1"><a class="header-anchor" href="#_17-usecontext的作用"><span>17. useContext的作用？</span></a></h2><ol><li>主要用于跨组件通信。</li><li>核心是父组件使用<code>Provider</code>包裹，给所有的子组件注入上下文。</li><li>子孙组件可以使用<code>useContext</code>拿到顶层组件注入的值。</li><li>一般修改状态，可以把状态和修改函数一起注入。</li></ol><h2 id="_18-react的并发更新是什么" tabindex="-1"><a class="header-anchor" href="#_18-react的并发更新是什么"><span>18. React的并发更新是什么？</span></a></h2><ol><li>fiber框架， 分片更新 =&gt; 异步更新</li><li>组件渲染过程，实际上是js的执行，因为js执行不可中断，所以导致如果一个组件特别消耗js，就会卡住渲染。</li><li>fiber架构 =&gt; 数据机构(深度优先遍历) =&gt; 细粒度的拆分任务</li></ol><ul><li>三个属性： child parent sibling</li><li>浏览器的空闲时间：requestIdleCallback</li></ul><div class="custom-container tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">TIP</p><p>requestIdleCallback兼容性不好，React目前使用PostMessage模拟实现的，它是宏任务的异步。</p></div><h2 id="_19-usetransition-和-usedeferredvalue的区别是什么" tabindex="-1"><a class="header-anchor" href="#_19-usetransition-和-usedeferredvalue的区别是什么"><span>19. useTransition 和 useDeferredValue的区别是什么？</span></a></h2><ol><li>解决的问题是一样的。</li><li>只是应用场景有点细微的区别。</li><li>一般<code>useDeferredValue</code>比较适合用于组件接收的<code>Props</code>参数导致的渲染缓慢优化。</li><li><code>useTransition</code>适用于组件内部本身的性能优化。</li></ol><h2 id="_20-react的hook一定要写在顶层作用域吗" tabindex="-1"><a class="header-anchor" href="#_20-react的hook一定要写在顶层作用域吗"><span>20. React的hook一定要写在顶层作用域吗？</span></a></h2><p>不是，比如use这个hook，这是一个特殊的存在。</p><h2 id="_21-usedebugvalue的作用" tabindex="-1"><a class="header-anchor" href="#_21-usedebugvalue的作用"><span>21. useDebugValue的作用？</span></a></h2><p>可以使用调试工具，做组件基本的<code>debug</code>, 记得开启严格模式。</p><h2 id="_22-单页面和多页面的区别是什么" tabindex="-1"><a class="header-anchor" href="#_22-单页面和多页面的区别是什么"><span>22. 单页面和多页面的区别是什么？</span></a></h2><ol><li><strong>单页面：</strong> 只有一个html页面</li><li><strong>多页面：</strong></li></ol><ul><li>多个html页面，通过window.location.href来进行切换。</li><li>缺点： 每一个页面都需要刷新重新加载资源，性能比较慢。</li><li>优点： SEO友好，适合C端项目。</li></ul>',17);function k(x,b){const o=i("router-link"),s=i("ExternalLinkIcon"),c=i("font");return d(),u("div",null,[e("nav",f,[e("ul",null,[e("li",null,[l(o,{to:"#_1-react和reactdom两个包分别有什么作用"},{default:a(()=>[t("1. React和ReactDom两个包分别有什么作用？")]),_:1})]),e("li",null,[l(o,{to:"#_2-react为什么有多个包-react是框架吗"},{default:a(()=>[t("2. React为什么有多个包？ React是框架吗？")]),_:1})]),e("li",null,[l(o,{to:"#_2-react组件的渲染过程是怎样的"},{default:a(()=>[t("2. React组件的渲染过程是怎样的？")]),_:1})]),e("li",null,[l(o,{to:"#_3-react中的虚拟dom是什么-它的作用是什么或者优点"},{default:a(()=>[t("3. React中的虚拟DOM是什么，它的作用是什么或者优点？")]),_:1})]),e("li",null,[l(o,{to:"#_4-严格模式的作用"},{default:a(()=>[t("4. 严格模式的作用？")]),_:1})]),e("li",null,[l(o,{to:"#_5-jsx的作用"},{default:a(()=>[t("5. JSX的作用？")]),_:1})]),e("li",null,[l(o,{to:"#_6-react中的生命周期方法有哪些-它们的作用是什么"},{default:a(()=>[t("6. React中的生命周期方法有哪些？它们的作用是什么？")]),_:1})]),e("li",null,[l(o,{to:"#_7-getderivedstatefromprops的作用是什么"},{default:a(()=>[t("7. getDerivedStateFromProps的作用是什么？")]),_:1})]),e("li",null,[l(o,{to:"#_8-getsnapshotbeforeupdate的特点"},{default:a(()=>[t("8. getSnapshotBeforeUpdate的特点？")]),_:1})]),e("li",null,[l(o,{to:"#_9-react是mvvm框架嘛"},{default:a(()=>[t("9. React是MVVM框架嘛？")]),_:1})]),e("li",null,[l(o,{to:"#_10-react如何实现mvvm"},{default:a(()=>[t("10. React如何实现MVVM？")]),_:1})]),e("li",null,[l(o,{to:"#_11-react的usestate是做什么的-它是同步更新吗"},{default:a(()=>[t("11. React的useState是做什么的？ 它是同步更新吗？")]),_:1})]),e("li",null,[l(o,{to:"#_12-react的性能优化hooks有那些-分别有什么作用"},{default:a(()=>[t("12. React的性能优化Hooks有那些？分别有什么作用？")]),_:1})]),e("li",null,[l(o,{to:"#_13-react中做组件渲染性能提升怎么做-react渲染规律"},{default:a(()=>[t("13. React中做组件渲染性能提升怎么做？ React渲染规律？")]),_:1})]),e("li",null,[l(o,{to:"#_14-react的更新是同步还是异步-为什么"},{default:a(()=>[t("14. React的更新是同步还是异步？ 为什么？")]),_:1})]),e("li",null,[l(o,{to:"#_15-useeffect和uselayouteffect的区别是什么"},{default:a(()=>[t("15. useEffect和useLayoutEffect的区别是什么？")]),_:1})]),e("li",null,[l(o,{to:"#_16-forwardref的作用"},{default:a(()=>[t("16. forwardRef的作用？")]),_:1})]),e("li",null,[l(o,{to:"#_17-usecontext的作用"},{default:a(()=>[t("17. useContext的作用？")]),_:1})]),e("li",null,[l(o,{to:"#_18-react的并发更新是什么"},{default:a(()=>[t("18. React的并发更新是什么？")]),_:1})]),e("li",null,[l(o,{to:"#_19-usetransition-和-usedeferredvalue的区别是什么"},{default:a(()=>[t("19. useTransition 和 useDeferredValue的区别是什么？")]),_:1})]),e("li",null,[l(o,{to:"#_20-react的hook一定要写在顶层作用域吗"},{default:a(()=>[t("20. React的hook一定要写在顶层作用域吗？")]),_:1})]),e("li",null,[l(o,{to:"#_21-usedebugvalue的作用"},{default:a(()=>[t("21. useDebugValue的作用？")]),_:1})]),e("li",null,[l(o,{to:"#_22-单页面和多页面的区别是什么"},{default:a(()=>[t("22. 单页面和多页面的区别是什么？")]),_:1})])])]),g,e("blockquote",null,[e("p",null,[e("a",m,[t("babel.j在线网址"),l(s)])])]),v,e("ol",null,[R,e("li",null,[e("strong",null,[l(c,{color:"#0286df"},{default:a(()=>[t("useLayoutEffect")]),_:1})]),t(" 的应用场景：在处理一些js动画时， 可以使用它来提前把动画位置确认，这样就避免在一定情况下出现闪烁或者跳动的问题。")])]),M])}const D=n(_,[["render",k],["__file","React.html.vue"]]),V=JSON.parse('{"path":"/series/audition/React.html","title":"React面试题","lang":"en-US","frontmatter":{"title":"React面试题","date":"2024-6-3","tags":["前端","面试","React"],"description":"React基础面试题","author":"一心只想回农村"},"headers":[{"level":2,"title":"1. React和ReactDom两个包分别有什么作用？","slug":"_1-react和reactdom两个包分别有什么作用","link":"#_1-react和reactdom两个包分别有什么作用","children":[]},{"level":2,"title":"2. React为什么有多个包？ React是框架吗？","slug":"_2-react为什么有多个包-react是框架吗","link":"#_2-react为什么有多个包-react是框架吗","children":[]},{"level":2,"title":"2. React组件的渲染过程是怎样的？","slug":"_2-react组件的渲染过程是怎样的","link":"#_2-react组件的渲染过程是怎样的","children":[]},{"level":2,"title":"3. React中的虚拟DOM是什么，它的作用是什么或者优点？","slug":"_3-react中的虚拟dom是什么-它的作用是什么或者优点","link":"#_3-react中的虚拟dom是什么-它的作用是什么或者优点","children":[]},{"level":2,"title":"4. 严格模式的作用？","slug":"_4-严格模式的作用","link":"#_4-严格模式的作用","children":[]},{"level":2,"title":"5. JSX的作用？","slug":"_5-jsx的作用","link":"#_5-jsx的作用","children":[]},{"level":2,"title":"6. React中的生命周期方法有哪些？它们的作用是什么？","slug":"_6-react中的生命周期方法有哪些-它们的作用是什么","link":"#_6-react中的生命周期方法有哪些-它们的作用是什么","children":[]},{"level":2,"title":"7. getDerivedStateFromProps的作用是什么？","slug":"_7-getderivedstatefromprops的作用是什么","link":"#_7-getderivedstatefromprops的作用是什么","children":[]},{"level":2,"title":"8. getSnapshotBeforeUpdate的特点？","slug":"_8-getsnapshotbeforeupdate的特点","link":"#_8-getsnapshotbeforeupdate的特点","children":[]},{"level":2,"title":"9. React是MVVM框架嘛？","slug":"_9-react是mvvm框架嘛","link":"#_9-react是mvvm框架嘛","children":[]},{"level":2,"title":"10. React如何实现MVVM？","slug":"_10-react如何实现mvvm","link":"#_10-react如何实现mvvm","children":[]},{"level":2,"title":"11. React的useState是做什么的？ 它是同步更新吗？","slug":"_11-react的usestate是做什么的-它是同步更新吗","link":"#_11-react的usestate是做什么的-它是同步更新吗","children":[]},{"level":2,"title":"12. React的性能优化Hooks有那些？分别有什么作用？","slug":"_12-react的性能优化hooks有那些-分别有什么作用","link":"#_12-react的性能优化hooks有那些-分别有什么作用","children":[]},{"level":2,"title":"13. React中做组件渲染性能提升怎么做？ React渲染规律？","slug":"_13-react中做组件渲染性能提升怎么做-react渲染规律","link":"#_13-react中做组件渲染性能提升怎么做-react渲染规律","children":[]},{"level":2,"title":"14.  React的更新是同步还是异步？ 为什么？","slug":"_14-react的更新是同步还是异步-为什么","link":"#_14-react的更新是同步还是异步-为什么","children":[]},{"level":2,"title":"15. useEffect和useLayoutEffect的区别是什么？","slug":"_15-useeffect和uselayouteffect的区别是什么","link":"#_15-useeffect和uselayouteffect的区别是什么","children":[]},{"level":2,"title":"16. forwardRef的作用？","slug":"_16-forwardref的作用","link":"#_16-forwardref的作用","children":[]},{"level":2,"title":"17. useContext的作用？","slug":"_17-usecontext的作用","link":"#_17-usecontext的作用","children":[]},{"level":2,"title":"18. React的并发更新是什么？","slug":"_18-react的并发更新是什么","link":"#_18-react的并发更新是什么","children":[]},{"level":2,"title":"19. useTransition 和 useDeferredValue的区别是什么？","slug":"_19-usetransition-和-usedeferredvalue的区别是什么","link":"#_19-usetransition-和-usedeferredvalue的区别是什么","children":[]},{"level":2,"title":"20. React的hook一定要写在顶层作用域吗？","slug":"_20-react的hook一定要写在顶层作用域吗","link":"#_20-react的hook一定要写在顶层作用域吗","children":[]},{"level":2,"title":"21. useDebugValue的作用？","slug":"_21-usedebugvalue的作用","link":"#_21-usedebugvalue的作用","children":[]},{"level":2,"title":"22. 单页面和多页面的区别是什么？","slug":"_22-单页面和多页面的区别是什么","link":"#_22-单页面和多页面的区别是什么","children":[]}],"git":{"createdTime":1717587743000,"updatedTime":1722309793000,"contributors":[{"name":"tiantao","email":"tiantao_yb@139.com","commits":3}]},"filePathRelative":"series/audition/React.md"}');export{D as comp,V as data};
